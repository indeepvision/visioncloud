"use strict";(self.webpackChunk_indeepvision_visioncloud_docs=self.webpackChunk_indeepvision_visioncloud_docs||[]).push([[182],{2247:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>m});var a=t(4041);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),g=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=g(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},y=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=g(t),y=i,m=u["".concat(s,".").concat(y)]||u[y]||c[y]||l;return t?a.createElement(m,o(o({ref:n},p),{},{components:t})):a.createElement(m,o({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,o=new Array(l);o[0]=y;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:i,o[1]=r;for(var g=2;g<l;g++)o[g]=t[g];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}y.displayName="MDXCreateElement"},6679:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>g});var a=t(9575),i=(t(4041),t(2247));const l={sidebar_position:3},o="Instance Segmentation",r={unversionedId:"user-guide/available-models/instance-segmentation",id:"user-guide/available-models/instance-segmentation",title:"Instance Segmentation",description:"What it does: Detects and segments each individual object separately, even when they overlap or touch.",source:"@site/docs/user-guide/available-models/instance-segmentation.md",sourceDirName:"user-guide/available-models",slug:"/user-guide/available-models/instance-segmentation",permalink:"/visioncloud/docs/user-guide/available-models/instance-segmentation",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"userGuide",previous:{title:"Segmentation",permalink:"/visioncloud/docs/user-guide/available-models/segmentation"}},s={},g=[{value:"Input",id:"input",level:2},{value:"Labels",id:"labels",level:3},{value:"Output",id:"output",level:2},{value:"How it looks in the platform",id:"how-it-looks-in-the-platform",level:3},{value:"When to Use Instance Segmentation",id:"when-to-use-instance-segmentation",level:2},{value:"Example Use Cases",id:"example-use-cases",level:3},{value:"Considerations for Training",id:"considerations-for-training",level:2},{value:"Additional Configuration",id:"additional-configuration",level:2}],p={toc:g},u="wrapper";function c(e){let{components:n,...t}=e;return(0,i.yg)(u,(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"instance-segmentation"},"Instance Segmentation"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"What it does:")," Detects and segments each individual object separately, even when they overlap or touch.  "),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Key Characteristics:"),"  "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Instance-level separation")," \u2013 Each object is a separate entity  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Handles overlaps")," \u2013 Can distinguish touching/overlapping objects  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Rich information")," \u2013 Provides class, location, size, shape for each object  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Most versatile")," \u2013 Can be used for almost any detection task  ")),(0,i.yg)("h2",{id:"input"},"Input"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Input:"),"  "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Whole images (e.g., photos of products, components, or scenes)  "),(0,i.yg)("li",{parentName:"ul"},"Corresponding pixel-level masks for training, with separate instances labeled individually  ")),(0,i.yg)("h3",{id:"labels"},"Labels"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Each object must be labeled separately with a unique instance ID  "),(0,i.yg)("li",{parentName:"ul"},"Assign a class to each object  "),(0,i.yg)("li",{parentName:"ul"},"Overlapping or touching objects must have separate masks  "),(0,i.yg)("li",{parentName:"ul"},"Maintain consistent labeling conventions across the dataset  ")),(0,i.yg)("admonition",{title:"Labeling Tips",type:"tip"},(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},"Use precise pixel-level boundaries for each object  "),(0,i.yg)("li",{parentName:"ul"},"Ensure no two overlapping objects share the same label  "),(0,i.yg)("li",{parentName:"ul"},"Keep instance IDs consistent if you track objects across frames  "),(0,i.yg)("li",{parentName:"ul"},"Review labels carefully to avoid merged instances  "))),(0,i.yg)("h2",{id:"output"},"Output"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Output:"),"  "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Individual masks for each detected object  "),(0,i.yg)("li",{parentName:"ul"},"Class labels and bounding boxes for each instance  "),(0,i.yg)("li",{parentName:"ul"},"Optionally, confidence scores per object  ")),(0,i.yg)("h3",{id:"how-it-looks-in-the-platform"},"How it looks in the platform"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Each object is highlighted separately  "),(0,i.yg)("li",{parentName:"ul"},"Users can view instance masks overlayed on the original image  "),(0,i.yg)("li",{parentName:"ul"},"Bounding boxes and class names are displayed for each instance  ")),(0,i.yg)("h2",{id:"when-to-use-instance-segmentation"},"When to Use Instance Segmentation"),(0,i.yg)("p",null,"Use Instance Segmentation when you need to:  "),(0,i.yg)("p",null,"\u2705 ",(0,i.yg)("strong",{parentName:"p"},"Multiple separate objects")," \u2013 Segment each object individually",(0,i.yg)("br",{parentName:"p"}),"\n","\u2705 ",(0,i.yg)("strong",{parentName:"p"},"Object counting")," \u2013 Know how many objects are present",(0,i.yg)("br",{parentName:"p"}),"\n","\u2705 ",(0,i.yg)("strong",{parentName:"p"},"Different classes per object")," \u2013 Objects may belong to different categories",(0,i.yg)("br",{parentName:"p"}),"\n","\u2705 ",(0,i.yg)("strong",{parentName:"p"},"Overlapping objects")," \u2013 Distinguish touching or overlapping items",(0,i.yg)("br",{parentName:"p"}),"\n","\u2705 ",(0,i.yg)("strong",{parentName:"p"},"Precise size measurement")," \u2013 Exact area of each object",(0,i.yg)("br",{parentName:"p"}),"\n","\u2705 ",(0,i.yg)("strong",{parentName:"p"},"Exact positioning")," \u2013 Location of each object",(0,i.yg)("br",{parentName:"p"}),"\n","\u2705 ",(0,i.yg)("strong",{parentName:"p"},"Individual tracking")," \u2013 Analyze each object separately  "),(0,i.yg)("h3",{id:"example-use-cases"},"Example Use Cases"),(0,i.yg)("div",{style:{display:"flex",justifyContent:"center"}},(0,i.yg)("table",null,(0,i.yg)("thead",null,(0,i.yg)("tr",null,(0,i.yg)("th",null,"Application"),(0,i.yg)("th",null,"What It Detects & Segments"))),(0,i.yg)("tbody",null,(0,i.yg)("tr",null,(0,i.yg)("td",null,"Defect inspection"),(0,i.yg)("td",null,"Each individual defect with size and location")),(0,i.yg)("tr",null,(0,i.yg)("td",null,"Object counting"),(0,i.yg)("td",null,"Count bottles, pills, products on a line")),(0,i.yg)("tr",null,(0,i.yg)("td",null,"Quality control"),(0,i.yg)("td",null,"Measure each product's dimensions individually")),(0,i.yg)("tr",null,(0,i.yg)("td",null,"Assembly verification"),(0,i.yg)("td",null,"Detect and verify each component separately")),(0,i.yg)("tr",null,(0,i.yg)("td",null,"Particle analysis"),(0,i.yg)("td",null,"Identify and measure individual particles"))))),(0,i.yg)("admonition",{title:"Most Versatile Option",type:"info"},(0,i.yg)("p",{parentName:"admonition"},"Instance Segmentation is the most powerful and flexible model type.",(0,i.yg)("br",{parentName:"p"}),"\n","It provides all the information that Classification or Segmentation provide, plus individual object details.",(0,i.yg)("br",{parentName:"p"}),"\n","When in doubt, choose Instance Segmentation.")),(0,i.yg)("admonition",{title:"Limitations of Instance Segmentation",type:"caution"},(0,i.yg)("p",{parentName:"admonition"},(0,i.yg)("strong",{parentName:"p"},"Limitations:")),(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},"\u274c Requires detailed labeling per object \u2013 more time-consuming  "),(0,i.yg)("li",{parentName:"ul"},"\u274c Computationally heavier than regular Segmentation or Classification  "),(0,i.yg)("li",{parentName:"ul"},"\u274c Larger datasets often needed for good generalization  "),(0,i.yg)("li",{parentName:"ul"},"\u274c More memory and GPU resources required for training and inference  ")),(0,i.yg)("p",{parentName:"admonition"},(0,i.yg)("strong",{parentName:"p"},"Better alternatives:")),(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("strong",{parentName:"li"},"Segmentation")," if you only need class-level regions without separating individual objects  "),(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("strong",{parentName:"li"},"Classification")," if you only need a single label per image  "))),(0,i.yg)("h2",{id:"considerations-for-training"},"Considerations for Training"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Input size:")," Typically 256x256 or 512x512 px; larger sizes improve instance accuracy  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Data augmentation:")," Rotation, flipping, scaling, color jitter  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Class balance:")," Ensure enough labeled instances per class  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Loss function:")," Combination of mask loss and bounding box/classification loss   "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Batch size and learning rate:")," Adjust according to dataset size and GPU memory  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Regularization:")," Dropout or weight decay may help reduce overfitting  ")),(0,i.yg)("h2",{id:"additional-configuration"},"Additional Configuration"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Label consistency:")," Ensure unique instance IDs and consistent class labeling across the dataset")))}c.isMDXComponent=!0}}]);